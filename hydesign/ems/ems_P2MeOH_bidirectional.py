# %%

import copy
import glob
import os
import time

# basic libraries
import numpy as np
import openmdao.api as om
import pandas as pd
import xarray as xr
import yaml
from docplex.mp.model import Model
from numpy import newaxis as na

from hydesign.ems.ems import expand_to_lifetime, split_in_batch
from hydesign.openmdao_wrapper import ComponentWrapper


class ems_P2MeOH_bidirectional:
    """Energy management optimization model for HPP with P2MeOH
    The energy management system optimization model consists in finding a compromise between maximizing the revenue generated by the plant over a period of time,
    and maximizing the production of green methanol (with enabling buying power from the grid to fulfill the remaining methanol demand).
    It also assigns a cost for rapid fluctuations of the battery in order to slow down its degradation.
    The EMS type is a CPLEX optimization.

    Parameters
    ----------
    wind_ts : WPP power time series
    solar_ts : PVP power time series
    elec_spot_price_ts : price time series
    P_batt_MW : battery power
    E_batt_MWh_t : battery energy capacity time series
    hpp_grid_connection : grid connection
    battery_depth_of_discharge : battery depth of discharge
    battery_charging_efficiency : battery charge efficiency
    peak_hr_quantile : quantile of price time series to define peak price hours
    cost_of_battery_P_fluct_in_peak_price_ratio : cost of battery power fluctuations computed as a peak price ratio
    n_full_power_hours_expected_per_day_at_peak_price : Penalty occurs if number of full power hours expected per day at peak price are not reached
    P_SOEC_MW: Electrolyzer power capacity
    eff_curve: Hydrogen production efficiency curve,

    price_green_MeOH : Price of green Methanol
    price_grid_MeOh : Price of grid Methanol
    elec_grid_price_ts : Purcchased elec for producing grid Hydrogen
    m_MeOH_demand_ts: Methanol demand times series
    P_heater_MW : Electrical heater power capacity
    heater_efficiency : Electrical heater efficiency
    lhv: Low heat value
    P_DAC_MW : DAC power capacity
    Q_DAC_MW : DAC heat capacity
    M_CO2 : Molar mass CO2
    M_H2 : Molar mass H2
    w : Multi-objective weight
    psi_DAC_MWhkg : DAC power consumption
    phi_DAC_MWhkg : DAC heat consumption
    P_reactor_MW : Reactor power capacity
    w_comp_reactor_MWhkg : Reactor power consumption
    H2O_yield : H2O production in reactor
    MeOH_yield : MeOH production yield in reactor
    m_MeOH_tank_flow_max_kg : Maximum mass of Methanol input at a time t in the tank
    m_MeOH_tank_max_kg : Methanol tank capacity
    charging_efficiency_MeOH_tank : charging efficiency of the Methanol tank

    Returns
    -------
    P_HPP_ts : HPP power time series
    P_curtailment_ts : curtailment time series
    P_charge_discharge_ts : battery charge/discharge power time series
    P_green_heater_ts : heater green power time series
    P_grid_heater_ts : heater grid power time series
    Q_green_DAC_ts : DAC green heat time series
    Q_grid_DAC_ts : DAC grid heat time series
    P_green_DAC_ts : DAC green power time series
    P_grid_DAC_ts : DAC grid power time series
    m_green_CO2_ts : green CO2 production time series
    m_grid_CO2_ts : grid CO2 production time series
    P_SOEC_grid_ts : SOEC grid power time series
    P_SOEC_green_ts : SOEC green power time series
    m_H2_green_ts : green H2 production time series
    m_H2_grid_ts : grid H2 production time series
    P_green_reactor_ts : reactor green power time series
    P_grid_reactor_ts : reactor grid power time series
    m_green_MeOH_reactor_ts : green MeOH production time series
    m_grid_MeOH_reactor_ts : grid MeOH production time series
    m_MeOH_tank_flow_ts : MeOH tank charge/discharge time series
    m_green_MeOH_dist_ts : green MeOH distribution time series
    P_purch_grid_ts : power purchased from the grid time series
    m_MeOH_tank_ts : MeOH tank mass level time series
    E_SOC_ts : battery energy level time series
    penalty_ts : penalty time series
    m_H2O_ts : H2O production rate time series
    """

    def __init__(
        self,
        N_time,
        eff_curve,
        eff_curve_prod_no_eff,
        MeOH_demand_scheme,
        life_h=25 * 365 * 24,
        ems_type="cplex",
        load_min_penalty_factor=1e6,
        electrolyzer_eff_curve_type="efficiency",
        batch_size=24 * 1,
    ):

        super().__init__()
        self.N_time = int(N_time)
        self.eff_curve = eff_curve
        self.eff_curve_prod_no_eff = eff_curve_prod_no_eff
        self.ems_type = ems_type
        self.life_h = int(life_h)
        self.batch_size = batch_size

        # self.load_min_penalty_factor = load_min_penalty_factor
        self.electrolyzer_eff_curve_type = electrolyzer_eff_curve_type
        self.MeOH_demand_scheme = MeOH_demand_scheme

        self.inputs = [
            (
                "wind_t",
                dict(desc="WPP power time series", units="MW", shape=[self.N_time]),
            ),
            (
                "solar_t",
                dict(desc="PVP power time series", units="MW", shape=[self.N_time]),
            ),
            (
                "elec_spot_price_t",
                dict(desc="Electricity price time series", shape=[self.N_time]),
            ),
            ("P_batt_MW", dict(desc="Battery power capacity", units="MW")),
            ("E_batt_MWh_t", dict(desc="Battery energy storage capacity")),
            ("hpp_grid_connection", dict(desc="Grid capacity", units="MW")),
            (
                "battery_depth_of_discharge",
                dict(desc="battery depth of discharge", units="MW"),
            ),
            ("battery_charging_efficiency", dict(desc="battery charge efficiency")),
            (
                "peak_hr_quantile",
                dict(
                    desc="Quantile of price tim sereis to define peak price hours (above this quantile).\n"
                    + "Only used for peak production penalty and for cost of battery degradation."
                ),
            ),
            (
                "cost_of_battery_P_fluct_in_peak_price_ratio",
                dict(
                    desc="cost of battery power fluctuations computed as a peak price ratio."
                ),
            ),
            (
                "n_full_power_hours_expected_per_day_at_peak_price",
                dict(
                    desc="Penalty occurs if nunmber of full power hours expected per day at peak price are not reached."
                ),
            ),
            ("lhv", dict(desc="Low heat value.")),
            ("P_SOEC_MW", dict(desc="SOEC power capacity.", units="MW")),
            (
                "m_MeOH_demand_t",
                dict(desc="MeOH demand times series.", units="kg", shape=[self.N_time]),
            ),
            ("penalty_factor_MeOH", dict(desc="penalty on producing grid methanol")),
            ("price_green_MeOH", dict(desc="Green methanol price")),
            ("price_grid_MeOH", dict(desc="Grid methanol price")),
            (
                "elec_grid_price_t",
                dict(desc="Grid electricity cost time series", shape=[self.N_time]),
            ),
            ("P_heater_MW", dict(desc="Heater power capacity.", units="MW")),
            # self.add_input(
            #     'heater_efficiency',
            #     desc="heater efficiency")
            ("P_DAC_MW", dict(desc="DAC power capacity.", units="MW")),
            ("Q_DAC_MW", dict(desc="DAC heat capacity.", units="MW")),
            ("M_CO2", dict(desc="CO2 molar mass")),
            ("M_H2", dict(desc="H2 molar mass")),
            ("M_H2O", dict(desc="H2O molar mass")),
            ("M_CH3OH", dict(desc="CH3OH molar mass")),
            (
                "w",
                dict(desc="parameter to measure the compromise in the multi-objective"),
            ),
            ("psi_DAC_MWhkg", dict(desc="DAC power consumption", units="MW/kg")),
            ("phi_DAC_MWhkg", dict(desc="DAC heat consumption", units="MW/kg")),
            ("P_reactor_MW", dict(desc="Reactor power capacity.", units="MW")),
            (
                "w_comp_reactor_MWhkg",
                dict(desc="Reactor power consumption", units="MW/kg"),
            ),
            ("H2O_yield", dict(desc="H2O production yield")),
            ("MeOH_yield", dict(desc="MeOH production yield")),
            (
                "m_MeOH_tank_flow_max_kg",
                dict(desc="MeOH tank mass flow capacity", units="kg"),
            ),
            ("m_MeOH_tank_max_kg", dict(desc="MeOH tank mass capacity", units="kg")),
            ("charging_efficiency_MeOH_tank", dict(desc="MeOH tank charge efficiency")),
        ]
        # ----------------------------------------------------------------------------------------------------------
        self.outputs = [
            (
                "wind_t_ext",
                dict(desc="WPP power time series", units="MW", shape=[self.life_h]),
            ),
            (
                "solar_t_ext",
                dict(desc="PVP power time series", units="MW", shape=[self.life_h]),
            ),
            (
                "elec_spot_price_t_ext",
                dict(desc="Electricity price time series", shape=[self.life_h]),
            ),
            (
                "elec_grid_price_t_ext",
                dict(desc="Grid electricity price time series", shape=[self.life_h]),
            ),
            (
                "m_MeOH_demand_t_ext",
                dict(
                    units="kg",
                    desc="Methanol demand time series",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_HPP_t",
                dict(desc="HPP power time series", units="MW", shape=[self.life_h]),
            ),
            (
                "P_curtailment_t",
                dict(
                    desc="HPP curtailed power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            ("total_curtailment", dict(desc="Total electricity curtailed")),
            (
                "P_charge_discharge_t",
                dict(
                    desc="Battery charge/discharge power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "E_SOC_t",
                dict(desc="Battery energy SOC time series", shape=[self.life_h + 1]),
            ),
            (
                "m_H2_green_t",
                dict(
                    desc="Green H2 production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_H2_grid_t",
                dict(
                    desc="Grid H2 production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_SOEC_green_t",
                dict(
                    desc="SOEC green power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_SOEC_grid_t",
                dict(
                    desc="SOEC grid power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_green_heater_t",
                dict(
                    desc="Heater green power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_grid_heater_t",
                dict(
                    desc="Heater grid power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_green_CO2_t",
                dict(
                    desc="Green CO2 production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_grid_CO2_t",
                dict(
                    desc="Grid CO2 production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "Q_green_DAC_t",
                dict(
                    desc="DAC green heat time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "Q_grid_DAC_t",
                dict(
                    desc="DAC grid heat time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_green_DAC_t",
                dict(
                    desc="DAC green power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_grid_DAC_t",
                dict(
                    desc="DAC grid power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_green_reactor_t",
                dict(
                    desc="Reactor green power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_grid_reactor_t",
                dict(
                    desc="Reactor grid power time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_green_MeOH_reactor_t",
                dict(
                    desc="Green MeOH production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_grid_MeOH_reactor_t",
                dict(
                    desc="Grid MeOH production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_H2O_t",
                dict(
                    desc="H2O production time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_MeOH_tank_t",
                dict(
                    desc="MeOH tank mass level time series",
                    units="kg",
                    shape=[self.life_h + 1],
                ),
            ),
            (
                "m_MeOH_tank_flow_t",
                dict(
                    desc="MeOH tank charge/discharge flow time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "m_green_MeOH_dist_t",
                dict(
                    desc="Green MeOH distribution time series",
                    units="kg",
                    shape=[self.life_h],
                ),
            ),
            (
                "P_purch_grid_t",
                dict(
                    desc="Power purchased from the grid time series",
                    units="MW",
                    shape=[self.life_h],
                ),
            ),
            (
                "penalty_t",
                dict(
                    desc="penalty for not reaching expected energy production at peak hours",
                    shape=[self.life_h],
                ),
            ),
        ]

    # def setup_partials(self):
    #    self.declare_partials('*', '*',  method='fd')

    def compute(self, **inputs):

        outputs = {}
        wind_t = inputs["wind_t"]
        solar_t = inputs["solar_t"]
        elec_spot_price_t = inputs["elec_spot_price_t"]
        elec_grid_price_t = inputs["elec_grid_price_t"]
        m_MeOH_demand_t = inputs["m_MeOH_demand_t"]

        if self.ems_type == "cplex":
            ems_WSB = ems_cplex_P2MeOH_bidirectional
        else:
            raise Warning(
                "This class should only be used for ems_cplex_P2MeOH_bidirectional"
            )

        # Avoid running an expensive optimization based ems if there is no battery
        # if ( P_batt_MW <= 1e-2 ) or (E_batt_MWh_t == 0):
        #  ems_WSB = ems_rule_based

        P_batt_MW = inputs["P_batt_MW"][0]
        E_batt_MWh_t = inputs["E_batt_MWh_t"][0]
        hpp_grid_connection = inputs["hpp_grid_connection"][0]
        m_MeOH_tank_max_kg = inputs["m_MeOH_tank_max_kg"][0]
        battery_depth_of_discharge = inputs["battery_depth_of_discharge"][0]
        battery_charging_efficiency = inputs["battery_charging_efficiency"][0]
        peak_hr_quantile = inputs["peak_hr_quantile"][0]
        cost_of_battery_P_fluct_in_peak_price_ratio = inputs[
            "cost_of_battery_P_fluct_in_peak_price_ratio"
        ][0]
        n_full_power_hours_expected_per_day_at_peak_price = inputs[
            "n_full_power_hours_expected_per_day_at_peak_price"
        ][0]
        penalty_factor_MeOH = inputs["penalty_factor_MeOH"][0]
        price_green_MeOH = inputs["price_green_MeOH"][0]
        price_grid_MeOH = inputs["price_grid_MeOH"][0]
        lhv = inputs["lhv"][0]
        P_SOEC_MW = inputs["P_SOEC_MW"][0]
        P_heater_MW = inputs["P_heater_MW"][0]
        P_DAC_MW = inputs["P_DAC_MW"][0]
        Q_DAC_MW = inputs["Q_DAC_MW"][0]
        P_reactor_MW = inputs["P_reactor_MW"][0]
        # heater_efficiency = inputs['heater_efficiency'][0]
        M_H2 = inputs["M_H2"][0]
        M_CO2 = inputs["M_CO2"][0]
        M_CH3OH = inputs["M_CH3OH"][0]
        M_H2O = inputs["M_H2O"][0]
        w = inputs["w"][0]
        psi_DAC_MWhkg = inputs["psi_DAC_MWhkg"][0]
        phi_DAC_MWhkg = inputs["phi_DAC_MWhkg"][0]
        w_comp_reactor_MWhkg = inputs["w_comp_reactor_MWhkg"][0]
        H2O_yield = inputs["H2O_yield"][0]
        MeOH_yield = inputs["MeOH_yield"][0]
        m_MeOH_tank_flow_max_kg = inputs["m_MeOH_tank_flow_max_kg"][0]
        m_MeOH_tank_max_kg = inputs["m_MeOH_tank_max_kg"][0]
        charging_efficiency_MeOH_tank = inputs["charging_efficiency_MeOH_tank"][0]
        MeOH_demand_scheme = self.MeOH_demand_scheme

        (
            P_HPP_ts,
            P_curtailment_ts,
            P_charge_discharge_ts,
            E_SOC_ts,
            m_H2_green_ts,
            m_H2_grid_ts,
            P_SOEC_green_ts,
            P_SOEC_grid_ts,
            P_green_heater_ts,
            P_grid_heater_ts,
            m_green_CO2_ts,
            m_grid_CO2_ts,
            Q_green_DAC_ts,
            Q_grid_DAC_ts,
            P_green_DAC_ts,
            P_grid_DAC_ts,
            P_green_reactor_ts,
            P_grid_reactor_ts,
            m_green_MeOH_reactor_ts,
            m_grid_MeOH_reactor_ts,
            m_H2O_ts,
            m_MeOH_tank_ts,
            m_MeOH_tank_flow_ts,
            m_green_MeOH_dist_ts,
            P_purch_grid_ts,
            penalty_ts,
        ) = ems_WSB(
            wind_ts=wind_t,
            solar_ts=solar_t,
            elec_spot_price_ts=elec_spot_price_t,
            P_batt_MW=P_batt_MW,
            E_batt_MWh_t=E_batt_MWh_t,
            hpp_grid_connection=hpp_grid_connection,
            battery_depth_of_discharge=battery_depth_of_discharge,
            battery_charging_efficiency=battery_charging_efficiency,
            P_SOEC_MW=P_SOEC_MW,
            lhv=lhv,
            eff_curve=self.eff_curve,
            eff_curve_prod_no_eff=self.eff_curve_prod_no_eff,
            price_green_MeOH=price_green_MeOH,
            price_grid_MeOH=price_grid_MeOH,
            elec_grid_price_ts=elec_grid_price_t,
            m_MeOH_demand_ts=m_MeOH_demand_t,
            P_heater_MW=P_heater_MW,
            # heater_efficiency = heater_efficiency,
            P_DAC_MW=P_DAC_MW,
            Q_DAC_MW=Q_DAC_MW,
            M_CO2=M_CO2,
            M_H2=M_H2,
            M_H2O=M_H2O,
            M_CH3OH=M_CH3OH,
            w=w,
            psi_DAC_MWhkg=psi_DAC_MWhkg,
            phi_DAC_MWhkg=phi_DAC_MWhkg,
            P_reactor_MW=P_reactor_MW,
            w_comp_reactor_MWhkg=w_comp_reactor_MWhkg,
            H2O_yield=H2O_yield,
            MeOH_yield=MeOH_yield,
            m_MeOH_tank_flow_max_kg=m_MeOH_tank_flow_max_kg,
            m_MeOH_tank_max_kg=m_MeOH_tank_max_kg,
            charging_efficiency_MeOH_tank=charging_efficiency_MeOH_tank,
            # min_power_standby = min_power_standby,
            # ramp_up_limit_t = WSPr_df.ramp_up_limit_t,
            # ramp_down_limit_t = WSPr_df.ramp_down_limit_t,
            penalty_factor_MeOH=penalty_factor_MeOH,
            MeOH_demand_scheme=MeOH_demand_scheme,
            peak_hr_quantile=peak_hr_quantile,
            cost_of_battery_P_fluct_in_peak_price_ratio=cost_of_battery_P_fluct_in_peak_price_ratio,
            n_full_power_hours_expected_per_day_at_peak_price=n_full_power_hours_expected_per_day_at_peak_price,
            electrolyzer_eff_curve_type=self.electrolyzer_eff_curve_type,
            batch_size=self.batch_size,
        )

        # Extend (by repeating them and stacking) all variable to full lifetime
        outputs["wind_t_ext"] = expand_to_lifetime(wind_t, life=self.life_h)
        outputs["solar_t_ext"] = expand_to_lifetime(solar_t, life=self.life_h)
        outputs["elec_spot_price_t_ext"] = expand_to_lifetime(
            elec_spot_price_t, life=self.life_h
        )
        outputs["elec_grid_price_t_ext"] = expand_to_lifetime(
            elec_grid_price_t, life=self.life_h
        )
        outputs["m_MeOH_demand_t_ext"] = expand_to_lifetime(
            m_MeOH_demand_t, life=self.life_h
        )
        outputs["P_HPP_t"] = expand_to_lifetime(P_HPP_ts, life=self.life_h)
        outputs["P_curtailment_t"] = expand_to_lifetime(
            P_curtailment_ts, life=self.life_h
        )
        outputs["total_curtailment"] = outputs["P_curtailment_t"].sum()
        outputs["P_charge_discharge_t"] = expand_to_lifetime(
            P_charge_discharge_ts, life=self.life_h
        )
        outputs["E_SOC_t"] = expand_to_lifetime(E_SOC_ts[:-1], life=self.life_h + 1)
        outputs["m_H2_green_t"] = expand_to_lifetime(m_H2_green_ts, life=self.life_h)
        outputs["m_H2_grid_t"] = expand_to_lifetime(m_H2_grid_ts, life=self.life_h)
        outputs["P_SOEC_green_t"] = expand_to_lifetime(
            P_SOEC_green_ts, life=self.life_h
        )
        outputs["P_SOEC_grid_t"] = expand_to_lifetime(P_SOEC_grid_ts, life=self.life_h)
        outputs["P_green_heater_t"] = expand_to_lifetime(
            P_green_heater_ts, life=self.life_h
        )
        outputs["P_grid_heater_t"] = expand_to_lifetime(
            P_grid_heater_ts, life=self.life_h
        )
        outputs["m_green_CO2_t"] = expand_to_lifetime(m_green_CO2_ts, life=self.life_h)
        outputs["m_grid_CO2_t"] = expand_to_lifetime(m_grid_CO2_ts, life=self.life_h)
        outputs["Q_green_DAC_t"] = expand_to_lifetime(Q_green_DAC_ts, life=self.life_h)
        outputs["Q_grid_DAC_t"] = expand_to_lifetime(Q_grid_DAC_ts, life=self.life_h)
        outputs["P_green_DAC_t"] = expand_to_lifetime(P_green_DAC_ts, life=self.life_h)
        outputs["P_grid_DAC_t"] = expand_to_lifetime(P_grid_DAC_ts, life=self.life_h)
        outputs["P_green_reactor_t"] = expand_to_lifetime(
            P_green_reactor_ts, life=self.life_h
        )
        outputs["P_grid_reactor_t"] = expand_to_lifetime(
            P_grid_reactor_ts, life=self.life_h
        )
        outputs["m_green_MeOH_reactor_t"] = expand_to_lifetime(
            m_green_MeOH_reactor_ts, life=self.life_h
        )
        outputs["m_grid_MeOH_reactor_t"] = expand_to_lifetime(
            m_grid_MeOH_reactor_ts, life=self.life_h
        )
        outputs["m_H2O_t"] = expand_to_lifetime(m_H2O_ts, life=self.life_h)
        outputs["m_MeOH_tank_t"] = expand_to_lifetime(
            m_MeOH_tank_ts[:-1], life=self.life_h + 1
        )
        outputs["m_MeOH_tank_flow_t"] = expand_to_lifetime(
            m_MeOH_tank_flow_ts, life=self.life_h
        )
        outputs["m_green_MeOH_dist_t"] = expand_to_lifetime(
            m_green_MeOH_dist_ts, life=self.life_h
        )
        outputs["P_purch_grid_t"] = expand_to_lifetime(
            P_purch_grid_ts, life=self.life_h
        )
        outputs["penalty_t"] = expand_to_lifetime(penalty_ts, life=self.life_h)
        out_keys = [
            "wind_t_ext",
            "solar_t_ext",
            "elec_spot_price_t_ext",
            "elec_grid_price_t_ext",
            "m_MeOH_demand_t_ext",
            "P_HPP_t",
            "P_curtailment_t",
            "total_curtailment",
            "P_charge_discharge_t",
            "E_SOC_t",
            "m_H2_green_t",
            "m_H2_grid_t",
            "P_SOEC_green_t",
            "P_SOEC_grid_t",
            "P_green_heater_t",
            "P_grid_heater_t",
            "m_green_CO2_t",
            "m_grid_CO2_t",
            "Q_green_DAC_t",
            "Q_grid_DAC_t",
            "P_green_DAC_t",
            "P_grid_DAC_t",
            "P_green_reactor_t",
            "P_grid_reactor_t",
            "m_green_MeOH_reactor_t",
            "m_grid_MeOH_reactor_t",
            "m_H2O_t",
            "m_MeOH_tank_t",
            "m_MeOH_tank_flow_t",
            "m_green_MeOH_dist_t",
            "P_purch_grid_t",
            "penalty_t",
        ]
        return [outputs[key] for key in out_keys]


class ems_P2MeOH_bidirectional_comp(ComponentWrapper):
    def __init__(self, **insta_inp):
        model = ems_P2MeOH_bidirectional(**insta_inp)
        super().__init__(
            inputs=model.inputs,
            outputs=model.outputs,
            function=model.compute,
            partial_options=[{"dependent": False, "val": 0}],
        )


def ems_cplex_P2MeOH_bidirectional(
    wind_ts,
    solar_ts,
    elec_spot_price_ts,
    P_batt_MW,
    E_batt_MWh_t,
    hpp_grid_connection,
    battery_depth_of_discharge,
    battery_charging_efficiency,
    P_SOEC_MW,
    lhv,
    eff_curve,
    eff_curve_prod_no_eff,
    price_green_MeOH,
    price_grid_MeOH,
    elec_grid_price_ts,
    m_MeOH_demand_ts,
    P_heater_MW,
    # heater_efficiency,
    P_DAC_MW,
    Q_DAC_MW,
    M_CO2,
    M_H2,
    M_H2O,
    M_CH3OH,
    w,
    psi_DAC_MWhkg,
    phi_DAC_MWhkg,
    P_reactor_MW,
    w_comp_reactor_MWhkg,
    H2O_yield,
    MeOH_yield,
    m_MeOH_tank_flow_max_kg,
    m_MeOH_tank_max_kg,
    charging_efficiency_MeOH_tank,
    penalty_factor_MeOH,
    MeOH_demand_scheme,
    peak_hr_quantile=0.9,
    cost_of_battery_P_fluct_in_peak_price_ratio=5,
    n_full_power_hours_expected_per_day_at_peak_price=3,
    electrolyzer_eff_curve_type="efficiency",
    batch_size=24 * 1,
):

    # split in batches, usually a week
    batches_all = split_in_batch(list(range(len(wind_ts))), batch_size)
    # Make sure the last batch is not smaller than the others
    # instead append it to the previous last one
    # batches = batches_all[:-1]
    # batches[-1] = batches_all[-2]+batches_all[-1]
    batches = batches_all

    # allocate vars
    P_HPP_ts = np.zeros(len(wind_ts))
    P_curtailment_ts = np.zeros(len(wind_ts))
    P_charge_discharge_ts = np.zeros(len(wind_ts))
    P_green_heater_ts = np.zeros(len(wind_ts))
    P_grid_heater_ts = np.zeros(len(wind_ts))
    Q_green_DAC_ts = np.zeros(len(wind_ts))
    Q_grid_DAC_ts = np.zeros(len(wind_ts))
    P_green_DAC_ts = np.zeros(len(wind_ts))
    P_grid_DAC_ts = np.zeros(len(wind_ts))
    m_green_CO2_ts = np.zeros(len(wind_ts))
    m_grid_CO2_ts = np.zeros(len(wind_ts))
    P_SOEC_grid_ts = np.zeros(len(wind_ts))
    P_SOEC_green_ts = np.zeros(len(wind_ts))
    m_H2_green_ts = np.zeros(len(wind_ts))
    m_H2_grid_ts = np.zeros(len(wind_ts))
    P_green_reactor_ts = np.zeros(len(wind_ts))
    P_grid_reactor_ts = np.zeros(len(wind_ts))
    m_green_MeOH_reactor_ts = np.zeros(len(wind_ts))
    m_grid_MeOH_reactor_ts = np.zeros(len(wind_ts))
    m_MeOH_tank_flow_ts = np.zeros(len(wind_ts))
    m_green_MeOH_dist_ts = np.zeros(len(wind_ts))
    P_purch_grid_ts = np.zeros(len(wind_ts))
    m_MeOH_tank_ts = np.zeros(len(wind_ts) + 1)
    E_SOC_ts = np.zeros(len(wind_ts) + 1)
    penalty_ts = np.zeros(len(wind_ts))
    m_H2O_ts = np.zeros(len(wind_ts))

    for ib, batch in enumerate(batches):
        wind_ts_sel = wind_ts[batch]
        solar_ts_sel = solar_ts[batch]
        elec_spot_price_ts_sel = elec_spot_price_ts[batch]
        elec_grid_price_ts_sel = elec_grid_price_ts[batch]
        m_MeOH_demand_ts_sel = m_MeOH_demand_ts[batch]
        # ramp_up_limit_t_sel = ramp_up_limit_t.iloc[batch]
        # ramp_down_limit_t_sel = ramp_down_limit_t.iloc[batch]

        (
            P_HPP_ts_batch,
            P_curtailment_ts_batch,
            P_charge_discharge_ts_batch,
            E_SOC_ts_batch,
            m_H2_green_ts_batch,
            m_H2_grid_ts_batch,
            P_SOEC_green_ts_batch,
            P_SOEC_grid_ts_batch,
            P_green_heater_ts_batch,
            P_grid_heater_ts_batch,
            m_green_CO2_ts_batch,
            m_grid_CO2_ts_batch,
            Q_green_DAC_ts_batch,
            Q_grid_DAC_ts_batch,
            P_green_DAC_ts_batch,
            P_grid_DAC_ts_batch,
            P_green_reactor_ts_batch,
            P_grid_reactor_ts_batch,
            m_green_MeOH_reactor_ts_batch,
            m_grid_MeOH_reactor_ts_batch,
            m_H2O_ts_batch,
            m_MeOH_tank_ts_batch,
            m_MeOH_tank_flow_ts_batch,
            m_green_MeOH_dist_ts_batch,
            P_purch_grid_ts_batch,
            penalty_ts_batch,
        ) = ems_cplex_parts_P2MeOH_bidirectional(
            wind_ts=wind_ts_sel,
            solar_ts=solar_ts_sel,
            elec_spot_price_ts=elec_spot_price_ts_sel,
            P_batt_MW=P_batt_MW,
            E_batt_MWh_t=E_batt_MWh_t,
            hpp_grid_connection=hpp_grid_connection,
            battery_depth_of_discharge=battery_depth_of_discharge,
            battery_charging_efficiency=battery_charging_efficiency,
            P_SOEC_MW=P_SOEC_MW,
            lhv=lhv,
            eff_curve=eff_curve,
            eff_curve_prod_no_eff=eff_curve_prod_no_eff,
            price_green_MeOH=price_green_MeOH,
            price_grid_MeOH=price_grid_MeOH,
            elec_grid_price_ts=elec_grid_price_ts_sel,
            m_MeOH_demand_ts=m_MeOH_demand_ts_sel,
            P_heater_MW=P_heater_MW,
            # heater_efficiency = heater_efficiency,
            # P_DAC_MW = P_DAC_MW,
            Q_DAC_MW=Q_DAC_MW,
            M_CO2=M_CO2,
            M_H2=M_H2,
            M_H2O=M_H2O,
            M_CH3OH=M_CH3OH,
            w=w,
            psi_DAC_MWhkg=psi_DAC_MWhkg,
            # phi_DAC_MWhkg = phi_DAC_MWhkg,
            # P_reactor_MW = P_reactor_MW,
            w_comp_reactor_MWhkg=w_comp_reactor_MWhkg,
            H2O_yield=H2O_yield,
            MeOH_yield=MeOH_yield,
            m_MeOH_tank_flow_max_kg=m_MeOH_tank_flow_max_kg,
            m_MeOH_tank_max_kg=m_MeOH_tank_max_kg,
            charging_efficiency_MeOH_tank=charging_efficiency_MeOH_tank,
            # m_MeOH_dist_max = m_MeOH_dist_max,
            penalty_factor_MeOH=penalty_factor_MeOH,
            MeOH_demand_scheme=MeOH_demand_scheme,
            peak_hr_quantile=peak_hr_quantile,
            cost_of_battery_P_fluct_in_peak_price_ratio=cost_of_battery_P_fluct_in_peak_price_ratio,
            n_full_power_hours_expected_per_day_at_peak_price=n_full_power_hours_expected_per_day_at_peak_price,
            electrolyzer_eff_curve_type=electrolyzer_eff_curve_type,
        )

        P_HPP_ts[batch] = P_HPP_ts_batch
        P_curtailment_ts[batch] = P_curtailment_ts_batch
        P_charge_discharge_ts[batch] = P_charge_discharge_ts_batch
        E_SOC_ts[batch] = E_SOC_ts_batch[:-1]
        penalty_ts[batch] = penalty_ts_batch
        m_H2_green_ts[batch] = m_H2_green_ts_batch
        m_H2_grid_ts[batch] = m_H2_grid_ts_batch
        P_SOEC_green_ts[batch] = P_SOEC_green_ts_batch
        P_SOEC_grid_ts[batch] = P_SOEC_grid_ts_batch
        P_green_heater_ts[batch] = P_green_heater_ts_batch
        P_grid_heater_ts[batch] = P_grid_heater_ts_batch
        m_green_CO2_ts[batch] = m_green_CO2_ts_batch
        m_grid_CO2_ts[batch] = m_grid_CO2_ts_batch
        Q_green_DAC_ts[batch] = Q_green_DAC_ts_batch
        Q_grid_DAC_ts[batch] = Q_grid_DAC_ts_batch
        P_green_DAC_ts[batch] = P_green_DAC_ts_batch
        P_grid_DAC_ts[batch] = P_grid_DAC_ts_batch
        P_green_reactor_ts[batch] = P_green_reactor_ts_batch
        P_grid_reactor_ts[batch] = P_grid_reactor_ts_batch
        m_green_MeOH_reactor_ts[batch] = m_green_MeOH_reactor_ts_batch
        m_grid_MeOH_reactor_ts[batch] = m_grid_MeOH_reactor_ts_batch
        m_H2O_ts[batch] = m_H2O_ts_batch
        m_MeOH_tank_ts[batch] = m_MeOH_tank_ts_batch[:-1]
        m_MeOH_tank_flow_ts[batch] = m_MeOH_tank_flow_ts_batch
        m_green_MeOH_dist_ts[batch] = m_green_MeOH_dist_ts_batch
        P_purch_grid_ts[batch] = P_purch_grid_ts_batch

    E_SOC_ts[-1] = E_SOC_ts[0]
    m_MeOH_tank_ts[-1] = m_MeOH_tank_ts[0]

    return (
        P_HPP_ts,
        P_curtailment_ts,
        P_charge_discharge_ts,
        E_SOC_ts,
        m_H2_green_ts,
        m_H2_grid_ts,
        P_SOEC_green_ts,
        P_SOEC_grid_ts,
        P_green_heater_ts,
        P_grid_heater_ts,
        m_green_CO2_ts,
        m_grid_CO2_ts,
        Q_green_DAC_ts,
        Q_grid_DAC_ts,
        P_green_DAC_ts,
        P_grid_DAC_ts,
        P_green_reactor_ts,
        P_grid_reactor_ts,
        m_green_MeOH_reactor_ts,
        m_grid_MeOH_reactor_ts,
        m_H2O_ts,
        m_MeOH_tank_ts,
        m_MeOH_tank_flow_ts,
        m_green_MeOH_dist_ts,
        P_purch_grid_ts,
        penalty_ts,
    )


def ems_cplex_parts_P2MeOH_bidirectional(
    wind_ts,
    solar_ts,
    elec_spot_price_ts,
    P_batt_MW,
    E_batt_MWh_t,
    hpp_grid_connection,
    battery_depth_of_discharge,
    battery_charging_efficiency,
    P_SOEC_MW,
    lhv,
    eff_curve,
    eff_curve_prod_no_eff,
    price_green_MeOH,
    price_grid_MeOH,
    elec_grid_price_ts,
    m_MeOH_demand_ts,
    P_heater_MW,
    # heater_efficiency,
    # P_DAC_MW,
    Q_DAC_MW,
    M_CO2,
    M_H2,
    M_H2O,
    M_CH3OH,
    w,
    psi_DAC_MWhkg,
    # phi_DAC_MWhkg,
    # P_reactor_MW,
    w_comp_reactor_MWhkg,
    H2O_yield,
    MeOH_yield,
    m_MeOH_tank_flow_max_kg,
    m_MeOH_tank_max_kg,
    charging_efficiency_MeOH_tank,
    penalty_factor_MeOH,
    MeOH_demand_scheme,
    peak_hr_quantile=0.9,
    cost_of_battery_P_fluct_in_peak_price_ratio=5,
    n_full_power_hours_expected_per_day_at_peak_price=3,
    electrolyzer_eff_curve_type="efficiency",
):
    """EMS solver implemented in cplex

    Parameters
    ----------
    wind_ts : WPP power time series
    solar_ts : PVP power time series
    elec_spot_price_ts : price time series
    P_batt_MW : battery power
    E_batt_MWh_t : battery energy capacity time series
    hpp_grid_connection : grid connection
    battery_depth_of_discharge : battery depth of discharge
    battery_charging_efficiency : battery charge efficiency
    peak_hr_quantile : quantile of price time series to define peak price hours
    cost_of_battery_P_fluct_in_peak_price_ratio : cost of battery power fluctuations computed as a peak price ratio
    n_full_power_hours_expected_per_day_at_peak_price : Penalty occurs if number of full power hours expected per day at peak price are not reached
    penalty_factor_MeOH : penalty coefficient used as the multi objective parameter to force the system to purchase green methanol
    P_SOEC_MW: Electrolyzer power capacity
    eff_curve: Hydrogen production efficiency curve,

    price_green_MeOH : Price of green Methanol
    price_grid_MeOh : Price of grid Methanol
    elec_grid_price_t : Purcchased elec for producing grid Hydrogen
    m_MeOH_demand_ts: Methanol demand times series
    P_heater_MW : Electrical heater power capacity
    heater_efficiency : Electrical heater efficiency
    lhv: Low heat value
    P_DAC_MW : DAC power capacity
    Q_DAC_MW : DAC heat capacity
    M_CO2 : Molar mass CO2
    M_H2 : Molar mass H2
    w : Multi-objective weight
    psi_DAC_MWhkg : DAC power consumption
    phi_DAC_MWhkg : DAC heat consumption
    P_reactor_MW : Reactor power capacity
    w_comp_reactor_MWhkg : Reactor power consumption
    H2O_yield : H2O production in reactor
    MeOH_yield : MeOH production yield in reactor
    m_MeOH_tank_flow_max_kg : Maximum mass of Methanol input at a time t in the tank
    m_MeOH_tank_max_kg : Methanol tank capacity
    charging_efficiency_MeOH_tank : charging efficiency of the Methanol tank

    Returns
    -------
    P_HPP_ts: HPP power time series
    P_curtailment_ts: HPP curtailed power time series
    P_charge_discharge_ts: Battery charge/discharge power time series
    E_SOC_ts: Battery energy SOC time series
    penalty_ts: penalty time series for not reaching expected energy production at peak hours
    m_H2_ts: Hydrogen production time series

    P_heater_ts : Electrical heater power consumption time series
    P_SOEC_green_ts : Electrolyzer green power consumption time series
    P_reactor_ts : Reactor power consumption time series
    P_SOEC_grid_ts : Electrolyser grid power consumption time series
    P_DAC_ts : DAC power consumption time series
    Q_DAC_ts : DAC heat consumption time series
    m_CO2_ts : CO2 production time series
    m_H2O_ts : H2O production time series
    m_green_MeOH_reactor_ts : Green Methanol production time series
    m_grid_MeOH_reactor_ts : Grid Methanol production time series
    m_MeOH_tank_flow_ts : mass of methanol going out or in the tank time series
    m_MeOH_tank_ts : mass of methanol in the tank time series
    m_MeOH_green_dist_ts : Gren Methanol distribution time series
    m_MeOH_dist_ts : Methanol distribution time series

    """

    # Penalties
    N_t = len(elec_spot_price_ts)
    N_days = N_t / 24
    e_peak_day_expected = (
        n_full_power_hours_expected_per_day_at_peak_price * hpp_grid_connection
    )
    e_peak_period_expected = e_peak_day_expected * N_days
    price_peak = np.quantile(elec_spot_price_ts, peak_hr_quantile)
    peak_hours_index = np.where(elec_spot_price_ts >= price_peak)[0]

    price_ts_to_max = price_peak - elec_spot_price_ts
    price_ts_to_max[price_ts_to_max < 0] = 0

    price_ts_to_max = pd.Series(price_ts_to_max)
    elec_spot_price_ts = pd.Series(elec_spot_price_ts)
    elec_grid_price_ts = pd.Series(elec_grid_price_ts)
    m_MeOH_demand_ts = pd.Series(m_MeOH_demand_ts)
    wind_ts = pd.Series(wind_ts)
    solar_ts = pd.Series(solar_ts)

    temp1 = 0.5 * price_ts_to_max[:-1].copy().to_numpy()
    temp2 = 0.5 * price_ts_to_max[1:].copy().to_numpy()

    temp = temp1 + temp2
    assert (
        temp.shape == price_ts_to_max[:-1].shape
    ), "Shapes do not match after addition!"
    price_ts_to_max[:-1] = temp

    mdl = Model(name="EMS")
    mdl.context.cplex_parameters.threads = 1
    # CPLEX parameter pg 87 Emphasize feasibility over optimality
    mdl.context.cplex_parameters.emphasis.mip = 1
    # mdl.context.cplex_parameters.timelimit = 1e-2
    # mdl.context.cplex_parameters.mip.limits.strongit = 3
    # mdl.context.cplex_parameters.mip.strategy.search = 1 #  branch and cut strategy; disable dynamic

    # cpx = mdl.get_cplex()
    # cpx.parameters.mip.tolerances.integrality.set(0)
    # cpx.parameters.simplex.tolerances.markowitz.set(0.999)
    # cpx.parameters.simplex.tolerances.optimality.set(1e-6)#1e-9)
    # cpx.parameters.simplex.tolerances.feasibility.set(1e-5)#1e-9)
    # cpx.parameters.mip.pool.intensity.set(2)
    # cpx.parameters.mip.pool.absgap.set(1e75)
    # cpx.parameters.mip.pool.relgap.set(1e75)
    # cpx.parameters.mip.limits.populate.set(50)

    time = list(range(len(elec_spot_price_ts)))
    # time set with an additional time slot for the last soc
    SOCtime = time + [len(elec_spot_price_ts)]

    eff_cor = 0.69

    # Variables definition
    P_HPP_ts = mdl.continuous_var_dict(
        time, lb=0, ub=hpp_grid_connection, name="HPP power output"
    )
    P_curtailment_ts = mdl.continuous_var_dict(time, lb=0, name="Curtailment")

    # Power charge/discharge from battery
    # Lower bound as large negative number in order to allow the variable to
    # have either positive or negative values
    P_charge_discharge_ts = mdl.continuous_var_dict(
        time, lb=-P_batt_MW, ub=P_batt_MW, name="Battery power"
    )
    # # Battery energy level, energy stored
    E_SOC_ts = mdl.continuous_var_dict(
        SOCtime, lb=0, name="Energy level"  # ub=E_batt_MWh_t.max(),
    )

    # Electrical heater
    P_green_heater_ts = mdl.continuous_var_dict(
        time, lb=0, ub=P_heater_MW, name="Green power consumption heater"
    )
    P_grid_heater_ts = mdl.continuous_var_dict(
        time, lb=0, ub=P_heater_MW, name="Power consumption heater"
    )

    # DAC
    Q_green_DAC_ts = mdl.continuous_var_dict(
        time, lb=0, ub=Q_DAC_MW, name="Green heat consumption DAC"
    )
    Q_grid_DAC_ts = mdl.continuous_var_dict(
        time, lb=0, ub=Q_DAC_MW, name="Grid heat consumption DAC"
    )
    P_green_DAC_ts = mdl.continuous_var_dict(
        time,
        lb=0,
        ub=P_SOEC_MW * psi_DAC_MWhkg * M_CO2 * eff_cor / (3 * M_H2 * lhv),
        name="Green power consumption DAC",
    )
    P_grid_DAC_ts = mdl.continuous_var_dict(
        time,
        lb=0,
        ub=P_SOEC_MW * psi_DAC_MWhkg * M_CO2 * eff_cor / (3 * M_H2 * lhv),
        name="Grid power consumption DAC",
    )
    m_green_CO2_ts = mdl.continuous_var_dict(time, lb=0, name="Mass of green CO2")
    m_grid_CO2_ts = mdl.continuous_var_dict(time, lb=0, name="Mass of grid CO2")

    # SOEC
    P_SOEC_grid_ts = mdl.continuous_var_dict(
        time, lb=0, name="Grid power purchased from the grid to the SOEC"
    )
    P_SOEC_green_ts = mdl.continuous_var_dict(
        time, lb=0, name="Green power to the SOEC"
    )
    m_H2_green_ts = mdl.continuous_var_dict(time, lb=0, name="Mass of green H2")
    m_H2_grid_ts = mdl.continuous_var_dict(time, lb=0, name="Mass of grid H2")

    # Methanol reactor
    P_green_reactor_ts = mdl.continuous_var_dict(
        time,
        lb=0,
        ub=P_SOEC_MW
        * w_comp_reactor_MWhkg
        * MeOH_yield
        * M_CH3OH
        * eff_cor
        / (3 * M_H2 * lhv),
        name="Green power consumption reactor",
    )
    P_grid_reactor_ts = mdl.continuous_var_dict(
        time,
        lb=0,
        ub=P_SOEC_MW
        * w_comp_reactor_MWhkg
        * MeOH_yield
        * M_CH3OH
        * eff_cor
        / (3 * M_H2 * lhv),
        name="Grid power consumption reactor",
    )
    m_green_MeOH_reactor_ts = mdl.continuous_var_dict(
        time, lb=0, name="Produced green methanol"
    )
    m_grid_MeOH_reactor_ts = mdl.continuous_var_dict(
        time, lb=0, name="Produced grid methanol"
    )
    m_H2O_ts = mdl.continuous_var_dict(time, lb=0, name="Mass of H2O")

    # Methanol tank
    m_MeOH_tank_ts = mdl.continuous_var_dict(
        SOCtime, lb=0, name="Mass of green Methanol in the tank"
    )
    m_MeOH_tank_flow_ts = mdl.continuous_var_dict(
        time,
        lb=-m_MeOH_tank_flow_max_kg,
        ub=m_MeOH_tank_flow_max_kg,
        name="Methanol flow in/out the tank",
    )

    # Methanol distribution
    m_green_MeOH_dist_ts = mdl.continuous_var_dict(
        time, lb=0, name="Mass of green Methanol distributed"
    )

    # Total electricity to buy from the grid
    P_purch_grid_ts = mdl.continuous_var_dict(
        time, lb=0, name="Power purchased from the grid"
    )

    # penalty if grid methanol is produced
    penalty_ts = mdl.continuous_var_dict(
        time, lb=0, name="penalty for producing grid methanol"
    )
    # e_penalty = mdl.continuous_var(name='e_penalty', lb=-1e12)

    # Piecewise function for "absolute value" function
    fabs = mdl.piecewise(-1, [(0, 0)], 1)

    if MeOH_demand_scheme == "fixed":

        mdl.maximize(
            # revenues and OPEX and Add cost for rapid charge-discharge for limiting the battery life use
            w
            * (
                mdl.sum(
                    elec_spot_price_ts.iloc[t] * P_HPP_ts[t]
                    + price_green_MeOH * m_green_MeOH_dist_ts[t]
                    + price_grid_MeOH * m_grid_MeOH_reactor_ts[t]
                    - elec_grid_price_ts.iloc[t] * P_purch_grid_ts[t]
                    for t in time
                )
                - mdl.sum(
                    fabs(P_charge_discharge_ts[t + 1] - P_charge_discharge_ts[t])
                    * cost_of_battery_P_fluct_in_peak_price_ratio
                    * price_ts_to_max.iloc[t]
                    for t in time[:-1]
                )
                - penalty_factor_MeOH
                * sum(m_MeOH_demand_ts.iloc[t] - m_green_MeOH_dist_ts[t] for t in time)
            )
        )

    if MeOH_demand_scheme == "infinite":

        mdl.maximize(
            # revenues and OPEX and Add cost for rapid charge-discharge for limiting the battery life use
            w
            * (
                mdl.sum(
                    elec_spot_price_ts.iloc[t] * P_HPP_ts[t]
                    + price_green_MeOH * m_green_MeOH_dist_ts[t]
                    for t in time
                )
                - mdl.sum(
                    fabs(P_charge_discharge_ts[t + 1] - P_charge_discharge_ts[t])
                    * cost_of_battery_P_fluct_in_peak_price_ratio
                    * price_ts_to_max.iloc[t]
                    for t in time[:-1]
                )
            )
        )

    # Constraints

    # # Piecewise function for "only positive" function
    f1 = mdl.piecewise(-1, [(0, 0)], 0)
    # Intitial and end SOC
    mdl.add_constraint(E_SOC_ts[SOCtime[0]] == 0.5 * E_batt_MWh_t)

    # # SOC at the end of the year has to be equal to SOC at the beginning of the year
    mdl.add_constraint(E_SOC_ts[SOCtime[-1]] == 0.5 * E_batt_MWh_t)

    mdl.add_constraint(m_MeOH_tank_ts[SOCtime[0]] == 0)
    mdl.add_constraint(m_MeOH_tank_ts[SOCtime[-1]] == 0)

    # piecewise linear representation of battery charge vs dischrage effciency
    f2 = mdl.piecewise(
        battery_charging_efficiency, [(0, 0)], 1 / battery_charging_efficiency
    )

    # piecewise linear representation of MeOH tank vs discharge efficiency
    f3 = mdl.piecewise(
        charging_efficiency_MeOH_tank, [(0, 0)], 1 / charging_efficiency_MeOH_tank
    )
    # piecewise linear representation of hydrogen produced from grid power
    f4 = mdl.piecewise(0, [(0, 0)], 1)

    # # Caclulating Hydrogen production as a function of load (piecewise linear approximation)
    if electrolyzer_eff_curve_type == "production":
        H2_curve_list = [(load * P_SOEC_MW, H2 * P_SOEC_MW) for load, H2 in eff_curve]
    elif electrolyzer_eff_curve_type == "efficiency":
        H2_curve_list = [
            (load * P_SOEC_MW, load * P_SOEC_MW * efficiency / lhv * 1000)
            for load, efficiency in eff_curve
        ]
    else:
        raise ValueError(
            f'electrolyzer_eff_curve_type is: "{electrolyzer_eff_curve_type}". Available options are ["production", "efficiency"]'
        )

    H2_prod = mdl.piecewise(0, H2_curve_list, 0)

    # Calculating the power needed from a ceratin amount of hydrogen
    P_SOEC_curve_list_no_eff = [
        (H2 * P_SOEC_MW, load * P_SOEC_MW if H2 != 0 else 0)
        for load, H2 in eff_curve_prod_no_eff
    ]
    P_SOEC_no_eff = mdl.piecewise(0, P_SOEC_curve_list_no_eff, 0)

    for t in time:
        # Time index for successive time step
        tt = t + 1
        # Delta_t of 1 hour
        dt = 1

        # Only one variable for battery
        mdl.add_constraint(
            P_HPP_ts[t]
            == wind_ts.iloc[t]
            + solar_ts.iloc[t]
            + P_charge_discharge_ts[t]
            - P_curtailment_ts[t]
            - P_SOEC_green_ts[t]
            - P_green_DAC_ts[t]
            - P_green_reactor_ts[t]
        )

        # # charge/dischrage equation
        mdl.add_constraint(
            E_SOC_ts[tt] == E_SOC_ts[t] - f2(P_charge_discharge_ts[t]) * dt
        )

        # # Constraining battery energy level to minimum battery level
        mdl.add_constraint(
            E_SOC_ts[t] >= (1 - battery_depth_of_discharge) * E_batt_MWh_t
        )

        # # Constraining battery energy level to maximum battery level
        mdl.add_constraint(E_SOC_ts[t] <= E_batt_MWh_t)

        # # # Battery charge/discharge within its power rating
        mdl.add_constraint(P_charge_discharge_ts[t] <= P_batt_MW)
        mdl.add_constraint(P_charge_discharge_ts[t] >= -P_batt_MW)

        # Constraints on the heat produced from the electrical heater
        # mdl.add_constraint(P_green_heater_ts[t] + P_grid_heater_ts[t] <= P_heater_MW)
        # mdl.add_constraint(Q_green_DAC_ts[t] == heater_efficiency*P_green_heater_ts[t])

        # Constraints on the DAC
        mdl.add_constraint(
            P_green_DAC_ts[t] + P_grid_DAC_ts[t]
            <= P_SOEC_MW * psi_DAC_MWhkg * M_CO2 * eff_cor / (3 * M_H2 * lhv)
        )
        # mdl.add_constraint(Q_green_DAC_ts[t] + Q_grid_DAC_ts[t] <= Q_DAC_MW)
        mdl.add_constraint(m_green_CO2_ts[t] == m_H2_green_ts[t] * M_CO2 / (3 * M_H2))
        mdl.add_constraint(P_green_DAC_ts[t] == psi_DAC_MWhkg * m_green_CO2_ts[t])
        # mdl.add_constraint(Q_green_DAC_ts[t] == phi_DAC_MWhkg*m_green_CO2_ts[t])

        # Calculating Hydrogen production with electrolyzer efficiency curve
        mdl.add_constraint(P_SOEC_green_ts[t] + P_SOEC_grid_ts[t] <= P_SOEC_MW)
        mdl.add_constraint(m_H2_green_ts[t] == H2_prod(P_SOEC_green_ts[t]) / 1000)

        # Constraints on the Methanol reactor
        mdl.add_constraint(
            P_green_reactor_ts[t] + P_grid_reactor_ts[t]
            <= P_SOEC_MW
            * w_comp_reactor_MWhkg
            * MeOH_yield
            * M_CH3OH
            * eff_cor
            / (3 * M_H2 * lhv)
        )
        mdl.add_constraint(
            P_green_reactor_ts[t] == w_comp_reactor_MWhkg * m_green_MeOH_reactor_ts[t]
        )
        mdl.add_constraint(
            m_green_MeOH_reactor_ts[t]
            == MeOH_yield * M_CH3OH / (3 * M_H2) * m_H2_green_ts[t]
        )

        # MeOH tank charge/dischrage equation
        mdl.add_constraint(
            m_MeOH_tank_ts[tt] == m_MeOH_tank_ts[t] - f3(m_MeOH_tank_flow_ts[t]) * dt
        )

        # Constraining MeOH tank mass level to maximum tank mass level
        mdl.add_constraint(m_MeOH_tank_ts[t] <= m_MeOH_tank_max_kg)

        # MeOH tank charge/discharge
        mdl.add_constraint(m_MeOH_tank_flow_ts[t] <= m_MeOH_tank_flow_max_kg)
        mdl.add_constraint(m_MeOH_tank_flow_ts[t] >= -m_MeOH_tank_flow_max_kg)

        # constarint on methanol distribution
        mdl.add_constraint(
            m_green_MeOH_dist_ts[t]
            == m_green_MeOH_reactor_ts[t] + m_MeOH_tank_flow_ts[t]
        )

        if MeOH_demand_scheme == "fixed":

            # Constraints for the post-process grid MeOH production
            mdl.add_constraint(
                m_grid_MeOH_reactor_ts[t]
                == m_MeOH_demand_ts.iloc[t] - m_green_MeOH_dist_ts[t]
            )
            mdl.add_constraint(
                m_H2_grid_ts[t]
                == m_grid_MeOH_reactor_ts[t] / (MeOH_yield * M_CH3OH / (3 * M_H2))
            )
            mdl.add_constraint(
                P_SOEC_grid_ts[t] == P_SOEC_no_eff(m_H2_grid_ts[t]) / eff_cor
            )  # Assumption to overestimate the amount of green electricity (efficiency for load equal to 0.23)
            mdl.add_constraint(
                P_grid_reactor_ts[t] == w_comp_reactor_MWhkg * m_grid_MeOH_reactor_ts[t]
            )
            mdl.add_constraint(m_grid_CO2_ts[t] == m_H2_grid_ts[t] * M_CO2 / (3 * M_H2))
            mdl.add_constraint(P_grid_DAC_ts[t] == psi_DAC_MWhkg * m_grid_CO2_ts[t])
            # mdl.add_constraint(Q_grid_DAC_ts[t] == phi_DAC_MWhkg*m_grid_CO2_ts[t])
            # mdl.add_constraint(Q_grid_DAC_ts[t] == heater_efficiency*P_grid_heater_ts[t])
            mdl.add_constraint(
                m_H2O_ts[t]
                == H2O_yield * (m_H2_green_ts[t] + m_H2_grid_ts[t]) * M_H2O / (3 * M_H2)
            )

            # Constraint on the power to purchase from the grid
            mdl.add_constraint(
                P_purch_grid_ts[t]
                == P_SOEC_grid_ts[t]
                + P_grid_reactor_ts[t]
                + P_grid_heater_ts[t]
                + P_grid_DAC_ts[t]
            )

            # Constraint on the amount of penalty paid
            mdl.add_constraint(
                penalty_ts[t]
                == penalty_factor_MeOH
                * (m_MeOH_demand_ts.iloc[t] - m_green_MeOH_dist_ts[t])
            )

    # Solving the problem
    sol = mdl.solve(log_output=False)
    #     log_output=True)
    # aa = mdl.get_solve_details()
    # print(aa.status)
    # if not aa.status=='integer optimal solution':
    #    print(aa.status)

    # print(mdl.export_to_string())
    # sol.display()
    if sol is None:
        print("Model couldn't find a solution")

    else:

        P_HPP_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_HPP_ts), orient="index"
        ).loc[:, 0]

        P_curtailment_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_curtailment_ts), orient="index"
        ).loc[:, 0]

        P_charge_discharge_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_charge_discharge_ts), orient="index"
        ).loc[:, 0]

        E_SOC_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(E_SOC_ts), orient="index"
        ).loc[:, 0]

        P_SOEC_green_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_SOEC_green_ts), orient="index"
        ).loc[:, 0]

        P_SOEC_grid_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_SOEC_grid_ts), orient="index"
        ).loc[:, 0]

        m_H2_green_value_dict = sol.get_value_dict(m_H2_green_ts)
        m_H2_green_value_full_value_dict = {
            t: m_H2_green_value_dict.get(t, 0) for t in time
        }
        m_H2_green_ts_df = pd.DataFrame.from_dict(
            m_H2_green_value_full_value_dict, orient="index"
        ).loc[:, 0]

        m_H2_grid_value_dict = sol.get_value_dict(m_H2_grid_ts)
        m_H2_grid_value_full_value_dict = {
            t: m_H2_grid_value_dict.get(t, 0) for t in time
        }
        m_H2_grid_ts_df = pd.DataFrame.from_dict(
            m_H2_grid_value_full_value_dict, orient="index"
        ).loc[:, 0]

        P_green_heater_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_green_heater_ts), orient="index"
        ).loc[:, 0]

        P_grid_heater_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(P_grid_heater_ts), orient="index"
        ).loc[:, 0]

        m_green_CO2_value_dict = sol.get_value_dict(m_green_CO2_ts)
        m_green_CO2_value_full_value_dict = {
            t: m_green_CO2_value_dict.get(t, 0) for t in time
        }
        m_green_CO2_ts_df = pd.DataFrame.from_dict(
            m_green_CO2_value_full_value_dict, orient="index"
        ).loc[:, 0]

        m_grid_CO2_value_dict = sol.get_value_dict(m_grid_CO2_ts)
        m_grid_CO2_value_full_value_dict = {
            t: m_grid_CO2_value_dict.get(t, 0) for t in time
        }
        m_grid_CO2_ts_df = pd.DataFrame.from_dict(
            m_grid_CO2_value_full_value_dict, orient="index"
        ).loc[:, 0]

        Q_green_DAC_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(Q_green_DAC_ts), orient="index"
        ).loc[:, 0]

        Q_grid_DAC_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(Q_grid_DAC_ts), orient="index"
        ).loc[:, 0]

        P_green_DAC_value_dict = sol.get_value_dict(P_green_DAC_ts)
        P_green_DAC_value_full_value_dict = {
            t: P_green_DAC_value_dict.get(t, 0) for t in time
        }
        P_green_DAC_ts_df = pd.DataFrame.from_dict(
            P_green_DAC_value_full_value_dict, orient="index"
        ).loc[:, 0]

        P_grid_DAC_value_dict = sol.get_value_dict(P_grid_DAC_ts)
        P_grid_DAC_value_full_value_dict = {
            t: P_grid_DAC_value_dict.get(t, 0) for t in time
        }
        P_grid_DAC_ts_df = pd.DataFrame.from_dict(
            P_grid_DAC_value_full_value_dict, orient="index"
        ).loc[:, 0]

        P_green_reactor_value_dict = sol.get_value_dict(P_green_reactor_ts)
        P_green_reactor_value_full_value_dict = {
            t: P_green_reactor_value_dict.get(t, 0) for t in time
        }
        P_green_reactor_ts_df = pd.DataFrame.from_dict(
            P_green_reactor_value_full_value_dict, orient="index"
        ).loc[:, 0]

        P_grid_reactor_value_dict = sol.get_value_dict(P_grid_reactor_ts)
        P_grid_reactor_value_full_value_dict = {
            t: P_grid_reactor_value_dict.get(t, 0) for t in time
        }
        P_grid_reactor_ts_df = pd.DataFrame.from_dict(
            P_grid_reactor_value_full_value_dict, orient="index"
        ).loc[:, 0]

        m_green_MeOH_reactor_value_dict = sol.get_value_dict(m_green_MeOH_reactor_ts)
        m_green_MeOH_reactor_value_full_value_dict = {
            t: m_green_MeOH_reactor_value_dict.get(t, 0) for t in time
        }
        m_green_MeOH_reactor_ts_df = pd.DataFrame.from_dict(
            m_green_MeOH_reactor_value_full_value_dict, orient="index"
        ).loc[:, 0]

        m_grid_MeOH_reactor_value_dict = sol.get_value_dict(m_grid_MeOH_reactor_ts)
        m_grid_MeOH_reactor_value_full_value_dict = {
            t: m_grid_MeOH_reactor_value_dict.get(t, 0) for t in time
        }
        m_grid_MeOH_reactor_ts_df = pd.DataFrame.from_dict(
            m_grid_MeOH_reactor_value_full_value_dict, orient="index"
        ).loc[:, 0]

        m_H2O_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(m_H2O_ts), orient="index"
        ).loc[:, 0]

        m_MeOH_tank_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(m_MeOH_tank_ts), orient="index"
        ).loc[:, 0]

        m_MeOH_tank_flow_ts_df = pd.DataFrame.from_dict(
            sol.get_value_dict(m_MeOH_tank_flow_ts), orient="index"
        ).loc[:, 0]

        m_green_MeOH_dist_value_dict = sol.get_value_dict(m_green_MeOH_dist_ts)
        m_green_MeOH_dist_value_full_value_dict = {
            t: m_green_MeOH_dist_value_dict.get(t, 0) for t in time
        }
        m_green_MeOH_dist_ts_df = pd.DataFrame.from_dict(
            m_green_MeOH_dist_value_full_value_dict, orient="index"
        ).loc[:, 0]

        P_purch_grid_value_dict = sol.get_value_dict(P_purch_grid_ts)
        P_purch_grid_value_full_value_dict = {
            t: P_purch_grid_value_dict.get(t, 0) for t in time
        }
        P_purch_grid_ts_df = pd.DataFrame.from_dict(
            P_purch_grid_value_full_value_dict, orient="index"
        ).loc[:, 0]

        penalty_ts_value_dict = sol.get_value_dict(penalty_ts)
        penalty_ts_value_full_value_dict = {
            t: penalty_ts_value_dict.get(t, 0) for t in time
        }
        penalty_ts_df = pd.DataFrame.from_dict(
            penalty_ts_value_full_value_dict, orient="index"
        )
        penalty_ts_df = (
            penalty_ts_df.iloc[:, 0]
            if penalty_ts_df.shape[1] > 0
            else pd.Series(0, index=time)
        )

    mdl.end()

    # Cplex sometimes returns missing values :O
    P_HPP_ts = P_HPP_ts_df.reindex(time, fill_value=0).values
    P_curtailment_ts = P_curtailment_ts_df.reindex(time, fill_value=0).values
    P_charge_discharge_ts = P_charge_discharge_ts_df.reindex(time, fill_value=0).values
    E_SOC_ts = E_SOC_ts_df.reindex(SOCtime, fill_value=0).values
    m_H2_green_ts = m_H2_green_ts_df.reindex(time, fill_value=0).values
    m_H2_grid_ts = m_H2_grid_ts_df.reindex(time, fill_value=0).values
    P_SOEC_green_ts = P_SOEC_green_ts_df.reindex(time, fill_value=0).values
    P_SOEC_grid_ts = P_SOEC_grid_ts_df.reindex(time, fill_value=0).values
    P_green_heater_ts = P_green_heater_ts_df.reindex(time, fill_value=0).values
    P_grid_heater_ts = P_grid_heater_ts_df.reindex(time, fill_value=0).values
    m_green_CO2_ts = m_green_CO2_ts_df.reindex(time, fill_value=0).values
    m_grid_CO2_ts = m_grid_CO2_ts_df.reindex(time, fill_value=0).values
    Q_green_DAC_ts = Q_green_DAC_ts_df.reindex(time, fill_value=0).values
    Q_grid_DAC_ts = Q_grid_DAC_ts_df.reindex(time, fill_value=0).values
    P_green_DAC_ts = P_green_DAC_ts_df.reindex(time, fill_value=0).values
    P_grid_DAC_ts = P_grid_DAC_ts_df.reindex(time, fill_value=0).values
    P_green_reactor_ts = P_green_reactor_ts_df.reindex(time, fill_value=0).values
    P_grid_reactor_ts = P_grid_reactor_ts_df.reindex(time, fill_value=0).values
    m_green_MeOH_reactor_ts = m_green_MeOH_reactor_ts_df.reindex(
        time, fill_value=0
    ).values
    m_grid_MeOH_reactor_ts = m_grid_MeOH_reactor_ts_df.reindex(
        time, fill_value=0
    ).values
    m_H2O_ts = m_H2O_ts_df.reindex(time, fill_value=0).values
    m_MeOH_tank_ts = m_MeOH_tank_ts_df.reindex(SOCtime, fill_value=0).values
    m_MeOH_tank_flow_ts = m_MeOH_tank_flow_ts_df.reindex(time, fill_value=0).values
    m_green_MeOH_dist_ts = m_green_MeOH_dist_ts_df.reindex(time, fill_value=0).values
    P_purch_grid_ts = P_purch_grid_ts_df.reindex(time, fill_value=0).values
    penalty_ts = penalty_ts_df.reindex(time, fill_value=0).values

    if len(P_HPP_ts_df) < len(wind_ts):
        # print('recomputing p_hpp')
        P_HPP_ts = (
            wind_ts.values
            + solar_ts.values
            + +P_charge_discharge_ts
            - P_curtailment_ts
            - P_green_heater_ts
            - P_SOEC_green_ts
            - P_green_DAC_ts
            - P_green_reactor_ts
        )

    return (
        P_HPP_ts,
        P_curtailment_ts,
        P_charge_discharge_ts,
        E_SOC_ts,
        m_H2_green_ts,
        m_H2_grid_ts,
        P_SOEC_green_ts,
        P_SOEC_grid_ts,
        P_green_heater_ts,
        P_grid_heater_ts,
        m_green_CO2_ts,
        m_grid_CO2_ts,
        Q_green_DAC_ts,
        Q_grid_DAC_ts,
        P_green_DAC_ts,
        P_grid_DAC_ts,
        P_green_reactor_ts,
        P_grid_reactor_ts,
        m_green_MeOH_reactor_ts,
        m_grid_MeOH_reactor_ts,
        m_H2O_ts,
        m_MeOH_tank_ts,
        m_MeOH_tank_flow_ts,
        m_green_MeOH_dist_ts,
        P_purch_grid_ts,
        penalty_ts,
    )


# %%
