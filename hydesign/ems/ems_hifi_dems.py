# -*- coding: utf-8 -*-

import numpy as np
# from numpy import newaxis as na
import pandas as pd
import openmdao.api as om
# import yaml

# import xarray as xr
# from docplex.mp.model import Model

from hydesign.HiFiEMS.utils import run
import hydesign.HiFiEMS.DEMS as EMS
from hydesign.ems.ems import expand_to_lifetime
# from hydesign.ems.ems import split_in_batch

class ems(om.ExplicitComponent):
    """Energy management optimization model
    The energy management system optimization model consists in maximizing the revenue generated by the plant over a period of time,
    including a possible penalty for not meeting the requirement of energy generation during peak hours over the period. It also assigns
    a cost for rapid fluctuations of the battery in order to slow down its degradation.
    The EMS type can be either a CPLEX optimization or a rule-based ems (Faster but not as optimal).

    Parameters
    ----------
    wind_t : WPP power time series [MW]
    solar_t : PVP power time series [MW]
    price_t : Electricity price time series 
    b_P : Battery power capacity [MW]
    b_E : Battery energy storage capacity [MW]
    G_MW : Grid capacity [MW]
    battery_depth_of_discharge : battery depth of discharge
    peak_hr_quantile : Quantile of price time series to define peak price hours (above this quantile)
    cost_of_battery_P_fluct_in_peak_price_ratio : cost of battery power fluctuations computed as a peak price ratio
    n_full_power_hours_expected_per_day_at_peak_price : Penalty occurs if number of full power hours expected per day at peak price are not reached

    Returns
    -------
    wind_t_ext : WPP power time series
    solar_t_ext : PVP power time series
    price_t_ext : Electricity price time series
    hpp_t : HPP power time series
    hpp_curt_t : HPP curtailed power time series
    b_t : Battery charge/discharge power time series
    b_E_SOC_t : Battery energy SOC time series
    penalty_t : Penalty for not reaching expected energy productin at peak hours
    
    """

    def __init__(
        self, 
        parameter_dict,
        simulation_dict,
        market_fn,
        N_time,
        life_y = 25,
        intervals_per_hour = 4,
        BM_model=False,
        RD_model=True,
        ):

        super().__init__()
        self.parameter_dict = parameter_dict
        self.simulation_dict = simulation_dict
        self.market_fn = market_fn
        self.intervals_per_hour = intervals_per_hour
        self.life_y = life_y
        self.life_h = 365 * 24 * life_y
        self.life_intervals = self.life_h * intervals_per_hour
        self.yearly_intervals = intervals_per_hour * 365 * 24
        self.BM_model = BM_model
        self.RD_model = RD_model
        self.N_time = N_time
        
    def setup(self):
        self.add_input('G_MW',
                       units='MW',
                       desc='Grid size')
        
        self.add_input('wind_MW',
                       units='MW',
                       desc='Wind plant nominal size')
        
        self.add_input('solar_MW',
                       units='MW',
                       desc='Solar plant nominal size')
        
        self.add_input('b_E',
                       desc="Battery energy storage capacity")
        

        self.add_input('battery_depth_of_discharge',
                       desc="battery depth of discharge",
                       units='MW')


        self.add_input('b_P',
                       desc="Battery power capacity",
                       units='MW')

        self.add_input('wind_t_da',
                        desc="day ahead power time series at the hub height",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('wind_t_ha',
                        desc="hour ahead power time series at the hub height",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('wind_t_rt',
                        desc="real time power time series at the hub height",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('wind_t_measurement',
                        desc="real time power time series at the hub height",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('solar_t_da',
                        desc="day ahead pv power time series",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('solar_t_ha',
                        desc="hour ahead pv power time series",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('solar_t_rt',
                        desc="real time pv power time series",
                        units='MW',
                        shape=[self.N_time])

        self.add_input('solar_t_measurement',
                        desc="real time pv power time series",
                        units='MW',
                        shape=[self.N_time])


        # ----------------------------------------------------------------------------------------------------------
        self.add_output('wind_t_ext',
                        desc="WPP power time series",
                        units='MW',
                        shape=[self.life_intervals])
        self.add_output('solar_t_ext',
                        desc="PVP power time series",
                        units='MW',
                        shape=[self.life_intervals])
        # self.add_output('price_t_ext',
        #                 desc="Electricity price time series",
        #                 shape=[self.life_intervals])

        self.add_output('hpp_t',
                        desc="HPP power time series",
                        units='MW',
                        shape=[self.life_intervals])
        self.add_output('hpp_curt_t',
                        desc="HPP curtailed power time series",
                        units='MW',
                        shape=[self.life_intervals])
        self.add_output('b_t',
                        desc="Battery charge/discharge power time series",
                        units='MW',
                        shape=[self.life_intervals])
        self.add_output('b_E_SOC_t',
                        desc="Battery energy SOC time series",
                        shape=[self.life_intervals + 1])
        
        self.add_output('P_HPP_SM_t_opt',desc='',shape=[self.life_intervals],)
        self.add_output('SM_price_cleared',desc='',shape=[self.life_h],)
        self.add_output('BM_dw_price_cleared',desc='',shape=[self.life_h],)
        self.add_output('BM_up_price_cleared',desc='',shape=[self.life_h],)
        # self.add_output('P_HPP_RT_ts',desc='',shape=[self.life_intervals],)
        self.add_output('P_HPP_RT_refs',desc='',shape=[self.life_intervals],)
        self.add_output('P_HPP_UP_bid_ts',desc='',shape=[self.life_intervals],)
        self.add_output('P_HPP_DW_bid_ts',desc='',shape=[self.life_intervals],)
        self.add_output('s_UP_t',desc='',shape=[self.life_intervals],)
        self.add_output('s_DW_t',desc='',shape=[self.life_intervals],)
        self.add_output('residual_imbalance',desc='',shape=[self.life_intervals],)
        self.add_output('P_HPP_ts',desc='',shape=[self.life_intervals],)
        self.add_output('P_curtailment_ts',desc='',shape=[self.life_intervals],)
        self.add_output('P_charge_discharge_ts',desc='',shape=[self.life_intervals],)
        self.add_output('E_SOC_ts',desc='',shape=[self.life_intervals + 1],)

    def setup_partials(self):
        self.declare_partials('*', '*', dependent=False, val=0)

    def compute_partials(self, inputs, partials):
        pass        
        

    def compute(self, inputs, outputs):
        parameter_dict = self.parameter_dict
        parameter_dict.update({
            # hpp parameters
            'hpp_grid_connection': float(inputs['G_MW']),  # in MW

            # hpp wind parameters
            'wind_capacity': float(inputs['wind_MW']), #in MW

            # hpp solar parameters
            'solar_capacity': float(inputs['solar_MW']),  # in MW
                       
            # hpp battery parameters
            'battery_energy_capacity': float(inputs['b_E']),  # in MWh
            'battery_power_capacity': float(inputs['b_P']),  # in MW
            'battery_minimum_SoC': 1 - float(inputs['battery_depth_of_discharge']),
            })
        
        Wind_data = pd.DataFrame({'Measurement': inputs['wind_t_measurement'] / inputs['wind_MW'],
                                  'DA': inputs['wind_t_da'] / inputs['wind_MW'],
                                  'HA': inputs['wind_t_ha'] / inputs['wind_MW'],
                                  'RT': inputs['wind_t_rt'] / inputs['wind_MW'],
                                  'time': pd.date_range(self.simulation_dict['start_date'], periods = 365 * 24 * 4, freq='15min')})
        
        Solar_data = pd.DataFrame({'Measurement': inputs['solar_t_measurement'] / inputs['solar_MW'],
                                   'DA': inputs['solar_t_da'] / inputs['solar_MW'],
                                   'HA': inputs['solar_t_ha'] / inputs['solar_MW'],
                                   'RT': inputs['solar_t_rt'] / inputs['solar_MW'],
                                   'time': pd.date_range(self.simulation_dict['start_date'], periods = 365 * 24 * 4, freq='15min')})

        Market_data = pd.read_csv(self.market_fn)

        simulation_dict = self.simulation_dict
        simulation_dict.update({
            'wind_as_component': 1,
            'solar_as_component': 1,  
            'battery_as_component': 1,
            
            'DA_wind': "DA",   #DA, Measurement
            'HA_wind': "HA" ,  #HA, Measurement
            'FMA_wind':"RT",#5min_ahead, Measurement
            'DA_solar': "DA",
            'HA_solar': "HA",
            'FMA_solar': "RT",
                
            'wind_df': Wind_data,
            'solar_df': Solar_data,
            'market_df': Market_data,
            })
        

        (P_HPP_SM_t_opt,
         SM_price_cleared,
         BM_dw_price_cleared,
         BM_up_price_cleared,
         P_HPP_RT_ts,
         P_HPP_RT_refs,
         P_HPP_UP_bid_ts,
         P_HPP_DW_bid_ts,
         s_UP_t,
         s_DW_t,
         residual_imbalance,
         P_curtailment_ts,
         P_charge_discharge_ts, 
         E_SOC_ts) = ems_cplex(parameter_dict=parameter_dict,
                               simulation_dict=simulation_dict,
                               BM_model=self.BM_model,
                               RD_model=self.RD_model,)

        E_SOC_ts[-1] = E_SOC_ts[0] 

        outputs['P_HPP_SM_t_opt']=expand_to_lifetime(
            P_HPP_SM_t_opt,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['SM_price_cleared']=expand_to_lifetime(
            SM_price_cleared,
            life = self.life_h, intervals_per_hour=1
            )
        outputs['BM_dw_price_cleared']=expand_to_lifetime(
            BM_dw_price_cleared,
            life = self.life_h, intervals_per_hour=1
            )
        outputs['BM_up_price_cleared']=expand_to_lifetime(
            BM_up_price_cleared,
            life = self.life_h, intervals_per_hour=1
            )
        outputs['P_HPP_ts']=expand_to_lifetime(
            P_HPP_RT_ts,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['P_HPP_RT_refs']=expand_to_lifetime(
            P_HPP_RT_refs,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['P_HPP_UP_bid_ts']=expand_to_lifetime(
            P_HPP_UP_bid_ts,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['P_HPP_DW_bid_ts']=expand_to_lifetime(
            P_HPP_DW_bid_ts,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['s_UP_t']=expand_to_lifetime(
            s_UP_t,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['s_DW_t']=expand_to_lifetime(
            s_DW_t,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['residual_imbalance']=expand_to_lifetime(
            residual_imbalance,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['P_curtailment_ts']=expand_to_lifetime(
            P_curtailment_ts,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['P_charge_discharge_ts']=expand_to_lifetime(
            P_charge_discharge_ts,
            life = self.life_intervals, intervals_per_hour=self.intervals_per_hour
            )
        outputs['E_SOC_ts']=expand_to_lifetime(
            E_SOC_ts,
            life = self.life_intervals + 1, intervals_per_hour=self.intervals_per_hour
            )

        
def ems_cplex(
    parameter_dict,
    simulation_dict,
    BM_model=False,
    RD_model=False,):

    (P_HPP_SM_t_opt,
     SM_price_cleared,
     BM_dw_price_cleared,
     BM_up_price_cleared,
     P_HPP_RT_ts,
     P_HPP_RT_refs,
     P_HPP_UP_bid_ts,
     P_HPP_DW_bid_ts,
     s_UP_t,
     s_DW_t,
     residual_imbalance,
     RES_RT_cur_ts,
     P_dis_RT_ts, 
     P_cha_RT_ts, 
     SoC_ts) = run(parameter_dict=parameter_dict,
                   simulation_dict=simulation_dict,
                   EMS=EMS,
                   EMStype="DEMS",
                   BM_model=BM_model,)
  
    P_charge_discharge_ts = P_dis_RT_ts - P_cha_RT_ts

    return (P_HPP_SM_t_opt,
            SM_price_cleared,
            BM_dw_price_cleared,
            BM_up_price_cleared,
            P_HPP_RT_ts,
            P_HPP_RT_refs,
            P_HPP_UP_bid_ts,
            P_HPP_DW_bid_ts,
            s_UP_t,
            s_DW_t,
            residual_imbalance,
            RES_RT_cur_ts,
            P_charge_discharge_ts, 
            SoC_ts,)

if __name__ == '__main__':
    from hydesign.examples import examples_filepath
    import pandas as pd
    
    dic = {'wind_fn': examples_filepath + "HiFiEMS_inputs/Power/Winddata2021_15min.csv",
           'solar_fn': examples_filepath + "HiFiEMS_inputs/Power/Solardata2021_15min.csv",
           'market_fn': examples_filepath + "HiFiEMS_inputs/Market/Market2021.csv",}

    Wind_data = pd.read_csv(dic["wind_fn"])
    '''
            Measurement            DA            HA            RT
    count  35040.000000  35040.000000  35040.000000  35040.000000
    mean       0.216720      0.227055      0.227055      0.216712
    std        0.235418      0.260050      0.260050      0.235421
    min        0.000000      0.000000      0.000000      0.000000
    25%        0.019800      0.011134      0.011134      0.019800
    50%        0.145600      0.143825      0.143825      0.145550
    75%        0.327600      0.337928      0.337928      0.327600
    max        1.000000      1.000000      1.000000      1.000000
    '''
    Solar_data = pd.read_csv(dic["solar_fn"])
    '''
            Measurement            DA            HA            RT
    count  35040.000000  35040.000000  35040.000000  35040.000000
    mean       0.119284      0.120088      0.120088      0.119284
    std        0.193897      0.207201      0.207201      0.193897
    min        0.000000      0.000000      0.000000      0.000000
    25%        0.000000      0.000000      0.000000      0.000000
    50%        0.000000      0.000000      0.000000      0.000000
    75%        0.182231      0.158699      0.158699      0.182231
    max        0.829113      0.929321      0.929321      0.829113
    '''
    Market_data = pd.read_csv(dic["market_fn"])
    '''
           SM_forecast  SM_forecast_LEAR  ...  reg_vol_Down  Unnamed: 12
    count  8760.000000       8760.000000  ...   8748.000000  1186.000000
    mean     83.018918         81.873855  ...    -43.144719    50.795430
    std      55.870573         53.748445  ...    155.466878    20.359182
    min     -20.693764         -3.388899  ...  -2162.000000    -2.210000
    25%      45.520623         46.838872  ...     -0.250000    37.860000
    50%      68.482143         68.039038  ...      0.000000    48.335000
    75%     101.689932        101.055036  ...      0.000000    60.840000
    max     553.576660        480.578725  ...      0.000000   147.480000
    '''
    
    parameter_dict = {
            
            # hpp parameters
            'hpp_grid_connection': 100,  # in MW
    
            # hpp wind parameters
            'wind_capacity': 120, #in MW
    
    
            # hpp solar parameters
            'solar_capacity': 10,  # in MW
           
    
            # hpp battery parameters
            'battery_energy_capacity': 120,  # in MWh
            'battery_power_capacity': 40,  # in MW
            'battery_minimum_SoC': 0.1,
            'battery_maximum_SoC': 0.9,
            'battery_initial_SoC': 0.1,
            'battery_hour_discharge_efficiency': 0.985,  #
            'battery_hour_charge_efficiency': 0.975,
            'battery_self_discharge_efficiency': 0,
            # hpp battery degradation parameters
            'battery_initial_degradation': 0,  
            'battery_marginal_degradation_cost': 142000, # in /MWh
            'battery_capital_cost': 142000, # in /MWh
            'degradation_in_optimization': 0, # 1:yes 0:no
            
            # bid parameters
            'max_up_bid': 50,
            'max_dw_bid': 50,
            'min_up_bid': 5,
            'min_dw_bid': 5,
            
            # interval parameters: note that DI must <= SI
            'dispatch_interval': 1/4,
            'settlement_interval': 1/4,
            
            'imbalance_fee': 0.13,  # DK: 0.13 €/MWh, other Nordic countries: , others: 0.001
            'battery_initial_degradation': 0,  # hpp battery degradation parameters
            'degradation_in_optimization': 0,         
            }
    
    simulation_dict = {
            'wind_as_component': 1,
            'solar_as_component': 1,  # The code does not support for solar power plant
            'battery_as_component': 1,
            'start_date': '1/1/21',
            'number_of_run_day': 50,   # 
            'out_dir':"./test/",
    
            'DA_wind': "DA",   #DA, Measurement
            'HA_wind': "HA" ,  #HA, Measurement
            'FMA_wind':"RT",#5min_ahead, Measurement
            'DA_solar': "DA",
            'HA_solar': "HA",
            'FMA_solar': "RT",
            'SP': "SM_forecast",  # SM_forecast;SM_cleared
            'RP': "reg_forecast", #reg_cleared;reg_forecast_pre
            'BP': 1, #1:forecast value 2: perfect value
            
            # Data
            # 'wind_fn': examples_filepath + "HiFiEMS_inputs/Winddata2021_15min.csv",
            # 'solar_fn': examples_filepath + "HiFiEMS_inputs/Solardata2021_15min.csv",
            # 'market_fn': examples_filepath + "HiFiEMS_inputs/Market2021.csv",
            'wind_df': Wind_data,
            'solar_df': Solar_data,
            'market_df': Market_data,
            
            # for DDEMS (spot market) -- Historical data
            # 'history_wind_fn': examples_filepath + "HiFiEMS_inputs/Winddata2022_15min.csv",
            # 'history_market_fn': examples_filepath + "HiFiEMS_inputs/Market2021.csv",
            
            # for REMS (balancing market)
            # 'HA_wind_error_ub': "5%_fc_error",
            # 'HA_wind_error_lb': "95%_fc_error",
            
            # for SEMS
            #'wind_scenario_fn': "../Data/Winddata2022_15min.csv",  # "../Data/probabilistic_wind2022.csv"
            # 'price_scenario_fn': None,  # "../Data/xxx.csv", if None then use the build in method to generate price scenarios
            # 'number_of_wind_scenario': 3, 
            # 'number_of_price_scenario': 3, 
        }
    
    out_keys = ['P_HPP_SM_t_opt',
                'SM_price_cleared',
                'BM_dw_price_cleared',
                'BM_up_price_cleared',
                'P_HPP_ts',
                'P_HPP_RT_refs',
                'P_HPP_UP_bid_ts',
                'P_HPP_DW_bid_ts',
                's_UP_t',
                's_DW_t',
                'residual_imbalance',
                'P_curtailment_ts',
                'P_charge_discharge_ts',
                'E_SOC_ts',]
    
        
    res = ems_cplex(parameter_dict, simulation_dict)
    lst = []
    for k, r in zip(out_keys, res):
        lst.append({'key': k, 'sum': r.sum(), 'mean': r.mean(), 'size':r.size})
    df = pd.DataFrame(lst)
    '''
                      key           sum          mean  size
    0          P_HPP_SM_t_opt  4.938688e+03  5.144467e+01    96
    1        SM_price_cleared  1.144810e+03  4.770042e+01    24
    2     BM_dw_price_cleared  1.018550e+03  4.243958e+01    24
    3     BM_up_price_cleared  1.144810e+03  4.770042e+01    24
    4             P_HPP_RT_ts  2.782215e+03  2.898141e+01    96
    5           P_HPP_RT_refs  4.938688e+03  5.144467e+01    96
    6         P_HPP_UP_bid_ts  0.000000e+00  0.000000e+00    96
    7         P_HPP_DW_bid_ts  0.000000e+00  0.000000e+00    96
    8                  s_UP_t  0.000000e+00  0.000000e+00    96
    9                  s_DW_t  0.000000e+00  0.000000e+00    96
    10     residual_imbalance -1.325445e+03 -1.380672e+01    96
    11               P_HPP_ts  2.782215e+03  2.898141e+01    96
    12       P_curtailment_ts  1.776357e-15  1.850372e-17    96
    13  P_charge_discharge_ts  3.755495e+02  3.911974e+00    96
    14               E_SOC_ts  2.664831e+01  2.775866e-01    96
    '''


    outputs = {}
    life_y = 25
    intervals_per_hour = 4
    life_h = life_y * 365 * 24
    life_intervals = life_h * intervals_per_hour
    outputs['P_HPP_SM_t_opt']=expand_to_lifetime(
        res[out_keys.index('P_HPP_SM_t_opt')],
        life=life_intervals)
    outputs['SM_price_cleared']=expand_to_lifetime(
        res[out_keys.index('SM_price_cleared')],
        life=life_h)
    outputs['BM_dw_price_cleared']=expand_to_lifetime(
        res[out_keys.index('BM_dw_price_cleared')],
        life=life_h)
    outputs['BM_up_price_cleared']=expand_to_lifetime(
        res[out_keys.index('BM_up_price_cleared')],
        life=life_h)
    # outputs['P_HPP_RT_ts']=expand_to_lifetime(
    #     res[out_keys.index('P_HPP_RT_ts')],
    #     life=life_intervals
    #     )
    outputs['P_HPP_RT_refs']=expand_to_lifetime(
        res[out_keys.index('P_HPP_RT_refs')],
        life=life_intervals
        )
    outputs['P_HPP_UP_bid_ts']=expand_to_lifetime(
        res[out_keys.index('P_HPP_UP_bid_ts')],
        life=life_intervals
        )
    outputs['P_HPP_DW_bid_ts']=expand_to_lifetime(
        res[out_keys.index('P_HPP_DW_bid_ts')],
        life=life_intervals
        )
    outputs['s_UP_t']=expand_to_lifetime(
        res[out_keys.index('s_UP_t')],
        life=life_intervals
        )
    outputs['s_DW_t']=expand_to_lifetime(
        res[out_keys.index('s_DW_t')],
        life=life_intervals
        )
    outputs['residual_imbalance']=expand_to_lifetime(
        res[out_keys.index('residual_imbalance')],
        life=life_intervals
        )
    outputs['P_HPP_ts']=expand_to_lifetime(
        res[out_keys.index('P_HPP_ts')],
        life=life_intervals
        )
    outputs['P_curtailment_ts']=expand_to_lifetime(
        res[out_keys.index('P_curtailment_ts')],
        life=life_intervals
        )
    outputs['P_charge_discharge_ts']=expand_to_lifetime(
        res[out_keys.index('P_charge_discharge_ts')],
        life=life_intervals
        )
    outputs['E_SOC_ts']=expand_to_lifetime(
        res[out_keys.index('E_SOC_ts')],
        life=life_intervals+1
        )
    
    for k, v in outputs.items():
        print(k, np.shape(v))

    from hydesign.HiFiEMS.utils import Revenue_calculation
    SM_revenue, _, _, BM_revenue, _ = Revenue_calculation(parameter_dict,
                        outputs['P_HPP_SM_t_opt'],
                        outputs['P_HPP_ts'],
                        outputs['P_HPP_RT_refs'],
                        outputs['SM_price_cleared'],
                        outputs['BM_dw_price_cleared'],
                        outputs['BM_up_price_cleared'],
                        outputs['P_HPP_UP_bid_ts'],
                        outputs['P_HPP_DW_bid_ts'],
                        outputs['s_UP_t'],
                        outputs['s_DW_t'],
                        BI=1,
                        )
    total_revenue = SM_revenue + BM_revenue
    print(total_revenue.sum() / 10**6)
    
    